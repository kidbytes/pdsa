What is not part of STL?
* Container adapters (stack, queue, priority_queue) and containers bitset and 
valarray are not part of STL because they lack iterator support.

* Arrays are part of C++ language and not the library.

* Extensions of the standard C++ library like - hash containers, singly linked
lists and ropes.


Terms
* Std sequence containers: vector, string, deque, list
  Std associative containers: set, multiset, map, multimap
  
* Input Iterators:  read-only. Each location may be read only once
  Output Iterators: write-only. Each location may be written only once
  - Modelled on reading and writing streams. istream_iterators and
    ostream_iterators are common manifestations
    
  Forward Iterators: have the capabilities of both input and output iterators.
                     Plus they can read/write a single location repeatedly.
                     They can only move forward.
  
  Bidirectional:     Forward Iterators + move backward.                    
                     Assoc containers and lists have these iterartors.
                     
  Random Access Iterators: Random Iterators + Iterator arithmetic          
                           vector, string and deque provide these iterators.          
                           Pointers intro arrays act as random iterators
                           
* Any class that overloads operator() is a functor class. Objects of these
classes are known as
 function objects. Any place where a real function works,
a function object also works.                           

Complexity
* STL gives complexity guarantees regardless of the STL platform used.
* Constant time - Performance is unaffected by changes in n.
                  Example, inserting into a linked list.
  Amortized constant time - Usually constant but some time take n.
  Logarithmic - An operation on million items would take only about
                3 times as much as 100 items. 
  Linear - Operation time increases proportional to n.
  
* Linear < Logarithmic < Constant


CONTAINERS:
* Contiguos memory containers aka array-based containers:
Element insertion or deletion requires shifting the remaining elements.

* Only a vector can be passed to a C interface.

* Standard vector, string and deque and non-standard rope are contiguos.

* Node base containers store only a single element per chunk of memory.
Insertion or deletion is easy. list, slist and all assoc containers are node
based. 

* There is no notion of position in assoc containers. If order is important
you can't use them

* If you are looking for random access iterators, you can only use vector,
string and deque.

* If the data in the container needs to be layout compatible with C, you
should use vector.

* If look up speed is important, you can use in order - hashed container,
sorted vector and std assoc containers.

* If you don't want containers that use reference counting, stay away from
strings. You use vector<char>.

* If you want transactional semantics - ability to rollback insertions and
deletions, use node based containers. List is the only node based container
that supports transaction for a range of elements. You need these sematics to
write exception safe code.

* Insertions and deletions don't invalidate any iterators, pointers, references
in node based containers (unless they point to the item being deleted). Whereas, 
contiguous containers invalidate all pointers and references.

* Deque is the only container that has random access iterators and whose 
pointers and references are not invalidated when insertions take place at
the end and nothing gets deleted. Note, iterators may be invalidated if
insertions take place. Plus this is the only container where pointers and
references may not be invalidate but only iterators get invalidated.

* Writing container independent code is a very bad idea - even if you are 
writing for only sequence based containers. For example, invalidation rules
are different for each container. Each container has its own capabilities 
and they are not interchangeable.

* Use typedef's for convenience:
  typedef vector<string> svec;
  typedef vector<string>::const_iterator siter;
  
ITEM 3:
* Make copying cheap. STL uses copyIn-copyOut mechanism. When you store, a copy
is stored and when you retrieve a copy is retrieved. When objects are moved due
to inserts and deletes, copies are made. Copying is made by using copy ctr() and
copy assignment operators. Inserting a derived class object into a base class
vector is an error. It leads to slicing. You are better off storing shared
pointers. When you reserve in a vector, you are not creating any objects. You
are just reserving space.


  
ITEM 4:
* Use empty() instead of size() when checking for empty container. empty() is 
guaranteed to be constant time operation for all standard containers. While
size() is linear for some. For example it is linear for lists. Lists support
splicing operation. Splicing is a constant time. If this method were to update
size information to make size() constant time, then splice wouldn't be constant
time. I.e. a container may have some special methods that are constant time and 
taking care of size in these methods may not be possible to maintain complexity.

ITEM 5:
* Use range member functions if available instead of generic algorithms. Example
you can use vector.assign() or insert() instead of generic copy. Copy() has a 
loop in it and performs by copying items. Member functions mostly are optimized.
* Range Construction: container::container(InputIterator begin, end)
* Range Insertion:    container::insert(position, InputIterator begin, end)
                      - Assoc containers don't have position
* Range Erasure:      iterator container::erase(iterator being, iterator end)
                      void container::erase(...) for assoc containers
                      - Apparently there is a performance penalty if iter has to
                        be returned for assoc containers.
 * Range Assignment   void container::assign(InputIterator begin, end) 
 
 ITEM 7:
 * Clean up new'd pointers in a container before the container is destroyed.
 When a container goes out of scope, it calls destructor for each of its 
 items. Destructor for a pointer is no op. You should use smart pointers
 instead.
 
 ITEM 9:
 Erasing options:
 * Sequence: c.erase(remove(c.begin(), c.end(), data), c.end())
 * List    : c.remove(data)
 * Assoc   : c.erase(data) [Uses equivalence instead of equality]
 You can also use remove_if(c.begin(),c.end(),badValue_predicate)
 
 ITEM 12:
 Thread safety
 1. Multiple threads may read from a container safely. There should not be
 any writes at that time.
 2. Multiple threads may simultaneously write to different containers.
 
 ITEM 13:
 * Prefer vector and string to dynamically allocated arrays. When T is a 
 character use a string. Both are fully fledged sequence containers and
 you can use all the stl algorithms on them.
 * If you are using reference counted strings in a multi-threaded environment
 there may be a performance hit because updates to the count are protected.
 You can use vector<char> instead.
 
 ITEM 14:
 Use reserve to avoid unnecessary reallocations. During a realloc, memory is 
 doubled, items copied from old memory, old items deleted and old memory 
 deallocated. This is expensive. Reserve operation mimizes reallocations.
 * size()     -> Returns how many elements are in the container
 * capacity() -> How many elements the container can hold. 
                 capacity() - size() is how many empty slots available
 * resize(n)  -> After resize, size() will return n. If n is smaller than
                 the current size, container shrinks. If n is lager, new
                 default constructed elements will be added to the end of
                 the container. If n is larger than current capacity, 
                 reallocation will take place before the elements are added.    
 * reserve(n) -> Changes capacity to at least n. If n less than current then
                 it is ignored.
 
 

 ITEM 16:
 Passing vector and string to legacy C API
 * &V[0] yields pointer to the first element since vector is constrained to
 be contiguous in memory just like arrays. You must check V is not empty(). 
 &*V.begin() also yields the same.
 
 * Data for strings is not guaranteed to be contiguous in memory and internal
 representation is not guaranteed to end in a null character. You should use
 S.c_str(). This method may return pointer to a copy of the data that is 
 contiguous but we do not know how the compiler implements it.
 
 ITEM 17:
 Use the swap trick to trim excess capacity.
 * When you erase items from a vector, the capacity doesn't shrink i.e. the
 memory footprint doesn't reduce. You can use the swap trick:
   vector<Contestants>(contestV).swap(contestV)
A temp is created with a copy of contestV and then temp and contestV are swapped.
When temp is created, it is created with the correct capacity. After the swap,
contestV looses unused capacity but temp has bloated capacity. But it is a temp

* Same trick works for strings.

* vector<T>().swap(inV)  --> clear a vector and shrink its capacity to minimum

ITEM 18:
Avoid using vector<bool>
* This is a pseduo container that doesn't actually contain bools but a packed
representation of bools. Each bool occupies a single bool.

* &v[0] doesn't return a pointer to the first bool. This is a basic requirement
of a vector.

* operator[] doesn't return a bool because the vector doesn't actually store
bools. It returns a proxy object called reference which is an inner class in
specialized version of vector<bool>. That is why bool* pb = &v[0] doesn't 
compile.

* You can use deque<bool>. However, deques don't have contiguous memory layout.
They don't have reserve() and capacity().

* You can bitset. This is not an stl container, so no iterators. Plus the size
is fixed at compile time meaning no inserts and deletes at run time.

ASSOCIATIVE CONTAINERS:
* Automatically keep their items sorted. Use equivalence for comparison instead
of equality. Maps don't do much with value part. They just store and retrieve.
Keys are important.

* The generic stl find algorithm and set::insert need to determine if two
values are the same. Find uses equality which is based on operator== and 
insert uses equivalences which is based on operator <. It is possible they
return different values.

* x == y is simple. It is true if values are equal. Note the implementation
may ignore certain book keeping fields for this comparison i.e objects need
not be equal at bit level.

* The definition of same in assoc containers is equivalence. Equivalence is 
based on sort order defined for the container. Two values are equivalent if 
neither precedes the other in sort order. The default sortorder for a set 
is less<T> which by default calls operator <. 

* Actually, every assoc container takes in a predicate as sorting criteria,
The method key_comp() returns the predicate and it is used for comparison.
So by default, key_comp() returns less<T> which calls operator <.

* If you define a case insensitive sorting criteria for a set, and insert
apple and Apple in order, Apple will not be inserted. set.find('aPpLe') would 
return an iterator the element. But, algorithm find() will not because it uses
operator== which is case sensitive unless it is overridden.

* Assoc containers use the same equivalence for both inserting and finding.

ITEM 20:
Implement sort order function for pointers.
* If you are storing pointers in your container, provide a custom sort oder
function when initializing the container.

struct Cust : public binary_function<const string*, const string*, bool> {
  bool operator(const string* ps1, const string* ps2) {
    return *ps1 < *ps2;
  }
}
set<string*, Cust> mySet;


ITEM 21:
Always have comparison function return false for equal values.
set<int, less_equal<int> > s;
Here the comparison function is less_equal which calls operator <= by
default. When iserting 2 equal integers, set uses the less_equal to determine
if those 2 are equal: !(i<=j) && !(j<=i). This actually evaluates to false. 
That means the set tries to insert 2 equal integers and the behavior is
undefined. The comparison function should define a strict weak ordering.

* Elements in an object of map<K,V> are of type pair<const K, V>. You cant
change the keys.

ITEM 23:
Replace associative containers with sorted vectors.
* If lookup speed is important, you may use non-standard hash containers. 
They offer constant time lookups compared to logarithmic time lookup of 
assoc containers which are implemented using balanced binary search trees.

* Balanced binary trees are dynamic and they are fine tuned for mixed inserts,
deletes and lookups. The order of operations is not known in advance. In many
cases we setup the data in advance and we do lookups. 

* A sorted vector gives better performance if lookups are not mixed with inserts
and deletes. BST's have more storage overhead due to pointers.
Arrays are contiguous and require less pages. There is locality. There can be 
more page faults with BST because the data is spread out among several pages.


                                       

 
  
  
