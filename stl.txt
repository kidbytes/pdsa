What is not part of STL?
* Container adapters (stack, queue, priority_queue) and containers bitset and 
valarray are not part of STL because they lack iterator support.

* Arrays are part of C++ language and not the library.

* Extensions of the standard C++ library like - hash containers, singly linked
lists and ropes.


Terms
* Std sequence containers: vector, string, deque, list
  Std associative containers: set, multiset, map, multimap
  
* Input Iterators:  read-only. Each location may be read only once
  Output Iterators: write-only. Each location may be written only once
  - Modelled on reading and writing streams. istream_iterators and
    ostream_iterators are common manifestations
    
  Forward Iterators: have the capabilities of both input and output iterators.
                     Plus they can read/write a single location repeatedly.
                     They can only move forward.
  
  Bidirectional:     Forward Iterators + move backward.                    
                     Assoc containers and lists have these iterartors.
                     
  Random Access Iterators: Random Iterators + Iterator arithmetic          
                           vector, string and deque provide these iterators.          
                           Pointers intro arrays act as random iterators
                           
* Any class that overloads operator() is a functor class. Objects of these
classes are known as
 function objects. Any place where a real function works,
a function object also works.                           

Complexity
* STL gives complexity guarantees regardless of the STL platform used.
* Constant time - Performance is unaffected by changes in n.
                  Example, inserting into a linked list.
  Amortized constant time - Usually constant but some time take n.
  Logarithmic - An operation on million items would take only about
                3 times as much as 100 items. 
  Linear - Operation time increases proportional to n.
  
* Linear < Logarithmic < Constant


CONTAINERS:
* Contiguos memory containers aka array-based containers:
Element insertion or deletion requires shifting the remaining elements.

* Only a vector can be passed to a C interface.

* Standard vector, string and deque and non-standard rope are contiguos.

* Node base containers store only a single element per chunk of memory.
Insertion or deletion is easy. list, slist and all assoc containers are node
based. 

* There is no notion of position in assoc containers. If order is important
you can't use them

* If you are looking for random access iterators, you can only use vector,
string and deque.

* If the data in the container needs to be layout compatible with C, you
should use vector.

* If look up speed is important, you can use in order - hashed container,
sorted vector and std assoc containers.

* If you don't want containers that use reference counting, stay away from
strings. You use vector<char>.

* If you want transactional semantics - ability to rollback insertions and
deletions, use node based containers. List is the only node based container
that supports transaction for a range of elements. You need these sematics to
write exception safe code.

* Insertions and deletions don't invalidate any iterators, pointers, references
in node based containers (unless they point to the item being deleted). Whereas, 
contiguous containers invalidate all pointers and references.

* Deque is the only container that has random access iterators and whose 
pointers and references are not invalidated when insertions take place at
the end and nothing gets deleted. Note, iterators may be invalidated if
insertions take place. Plus this is the only container where pointers and
references may not be invalidate but only iterators get invalidated.

* Writing container independent code is a very bad idea - even if you are 
writing for only sequence based containers. For example, invalidation rules
are different for each container. Each container has its own capabilities 
and they are not interchangeable.

* Use typedef's for convenience:
  typedef vector<string> svec;
  typedef vector<string>::const_iterator siter;
  
ITEM 3:
* Make copying cheap. STL uses copyIn-copyOut mechanism. When you store, a copy
is stored and when you retrieve a copy is retrieved. When objects are moved due
to inserts and deletes, copies are made. Copying is made by using copy ctr() and
copy assignment operators. Inserting a derived class object into a base class
vector is an error. It leads to slicing. You are better off storing shared
pointers. When you reserve in a vector, you are not creating any objects. You
are just reserving space.


  
ITEM 4:
* Use empty() instead of size() when checking for empty container. empty() is 
guaranteed to be constant time operation for all standard containers. While
size() is linear for some. For example it is linear for lists. Lists support
splicing operation. Splicing is a constant time. If this method were to update
size information to make size() constant time, then splice wouldn't be constant
time. I.e. a container may have some special methods that are constant time and 
taking care of size in these methods may not be possible to maintain complexity.

ITEM 5:
* Use range member functions if available instead of generic algorithms. Example
you can use vector.assign() or insert() instead of generic copy. Copy() has a 
loop in it and performs by copying items. Member functions mostly are optimized.
* Range Construction: container::container(InputIterator begin, end)
* Range Insertion:    container::insert(position, InputIterator begin, end)
                      - Assoc containers don't have position
* Range Erasure:      iterator container::erase(iterator being, iterator end)
                      void container::erase(...) for assoc containers
                      - Apparently there is a performance penalty if iter has to
                        be returned for assoc containers.
 * Range Assignment   void container::assign(InputIterator begin, end) 
 
 ITEM 7:
 * Clean up new'd pointers in a container before the container is destroyed.
 When a container goes out of scope, it calls destructor for each of its 
 items. Destructor for a pointer is no op. You should use smart pointers
 instead.
 
 ITEM 9:
 Erasing options:
 * Sequence: c.erase(remove(c.begin(), c.end(), data), c.end())
 * List    : c.remove(data)
 * Assoc   : c.erase(data) [Uses equivalence instead of equality]
 You can also use remove_if(c.begin(),c.end(),badValue_predicate)
 
 ITEM 12:
 Thread safety
 1. Multiple threads may read from a container safely. There should not be
 any writes at that time.
 2. Multiple threads may simultaneously write to different containers.
 
 ITEM 13:
 * Prefer vector and string to dynamically allocated arrays. When T is a 
 character use a string. Both are fully fledged sequence containers and
 you can use all the stl algorithms on them.
 * If you are using reference counted strings in a multi-threaded environment
 there may be a performance hit because updates to the count are protected.
 You can use vector<char> instead.
 
 ITEM 14:
 Use reserve to avoid unnecessary reallocations. During a realloc, memory is 
 doubled, items copied from old memory, old items deleted and old memory 
 deallocated. This is expensive. Reserve operation mimizes reallocations.
 * size()     -> Returns how many elements are in the container
 * capacity() -> How many elements the container can hold. 
                 capacity() - size() is how many empty slots available
 * resize(n)  -> After resize, size() will return n. If n is smaller than
                 the current size, container shrinks. If n is lager, new
                 default constructed elements will be added to the end of
                 the container. If n is larger than current capacity, 
                 reallocation will take place before the elements are added.    
 * reserve(n) -> Changes capacity to at least n. If n less than current then
                 it is ignored.
 
 

 ITEM 16:
 Passing vector and string to legacy C API
 * &V[0] yields pointer to the first element since vector is constrained to
 be contiguous in memory just like arrays. You must check V is not empty(). 
 &*V.begin() also yields the same.
 
 * Data for strings is not guaranteed to be contiguous in memory and internal
 representation is not guaranteed to end in a null character. You should use
 S.c_str(). This method may return pointer to a copy of the data that is 
 contiguous but we do not know how the compiler implements it.
 
 ITEM 17:
 Use the swap trick to trim excess capacity.
 * When you erase items from a vector, the capacity doesn't shrink i.e. the
 memory footprint doesn't reduce. You can use the swap trick:
   vector<Contestants>(contestV).swap(contestV)
A temp is created with a copy of contestV and then temp and contestV are swapped.
When temp is created, it is created with the correct capacity. After the swap,
contestV looses unused capacity but temp has bloated capacity. But it is a temp

* Same trick works for strings.

* vector<T>().swap(inV)  --> clear a vector and shrink its capacity to minimum

ITEM 18:
Avoid using vector<bool>
* This is a pseduo container that doesn't actually contain bools but a packed
representation of bools. Each bool occupies a single bool.

* &v[0] doesn't return a pointer to the first bool. This is a basic requirement
of a vector.

* operator[] doesn't return a bool because the vector doesn't actually store
bools. It returns a proxy object called reference which is an inner class in
specialized version of vector<bool>. That is why bool* pb = &v[0] doesn't 
compile.

* You can use deque<bool>. However, deques don't have contiguous memory layout.
They don't have reserve() and capacity().

* You can bitset. This is not an stl container, so no iterators. Plus the size
is fixed at compile time meaning no inserts and deletes at run time.

ASSOCIATIVE CONTAINERS:
* Automatically keep their items sorted. Use equivalence for comparison instead
of equality. Maps don't do much with value part. They just store and retrieve.
Keys are important.

* The generic stl find algorithm and set::insert need to determine if two
values are the same. Find uses equality which is based on operator== and 
insert uses equivalences which is based on operator <. It is possible they
return different values.

* x == y is simple. It is true if values are equal. Note the implementation
may ignore certain book keeping fields for this comparison i.e objects need
not be equal at bit level.

* The definition of same in assoc containers is equivalence. Equivalence is 
based on sort order defined for the container. Two values are equivalent if 
neither precedes the other in sort order. The default sortorder for a set 
is less<T> which by default calls operator <. 

* Actually, every assoc container takes in a predicate as sorting criteria,
The method key_comp() returns the predicate and it is used for comparison.
So by default, key_comp() returns less<T> which calls operator <.

* If you define a case insensitive sorting criteria for a set, and insert
apple and Apple in order, Apple will not be inserted. set.find('aPpLe') would 
return an iterator the element. But, algorithm find() will not because it uses
operator== which is case sensitive unless it is overridden.

* Assoc containers use the same equivalence for both inserting and finding.

ITEM 20:
Implement sort order function for pointers.
* If you are storing pointers in your container, provide a custom sort oder
function when initializing the container.

struct Cust : public binary_function<const string*, const string*, bool> {
  bool operator(const string* ps1, const string* ps2) {
    return *ps1 < *ps2;
  }
}
set<string*, Cust> mySet;


ITEM 21:
Always have comparison function return false for equal values.
set<int, less_equal<int> > s;
Here the comparison function is less_equal which calls operator <= by
default. When iserting 2 equal integers, set uses the less_equal to determine
if those 2 are equal: !(i<=j) && !(j<=i). This actually evaluates to false. 
That means the set tries to insert 2 equal integers and the behavior is
undefined. The comparison function should define a strict weak ordering.

* Elements in an object of map<K,V> are of type pair<const K, V>. You cant
change the keys.

ITEM 23:
Replace associative containers with sorted vectors.
* If lookup speed is important, you may use non-standard hash containers. 
They offer constant time lookups compared to logarithmic time lookup of 
assoc containers which are implemented using balanced binary search trees.

* Balanced binary trees are dynamic and they are fine tuned for mixed inserts,
deletes and lookups. The order of operations is not known in advance. In many
cases we setup the data in advance and we do lookups. 

* A sorted vector gives better performance if lookups are not mixed with 
inserts and deletes. BST's have more storage overhead due to pointers.
Arrays are contiguous and require less pages. There is locality. There can be 
more page faults with BST because the data is spread out among several pages.

vector<T> v;
sort(v.begin(), v.end());
if (binary_search(v.egin(), v.end(), w) {}
vector<>::iterator i = lower_bound(v.begin(), v.end(), w);
if (i != v.end) && !(v < *i)

pair<vector<T>::iterator, vector<T>::iterator> range = 
                                       equal_range(v.gegin(), v.end(), w);
if (range.first != range.second) ..
sort(v.begin(), v.end());
                                       
* To emulate a map, type of the  data stored in the vector will be pair<K,V>.
Both the components of the pair must be assignable. You need to write a custom 
comparison functions for sorting and lookups because you only need to compare 
the firt item K in a pair. The default pair's operator <  looks at both K & V. 
Actually you will need 2 versions. Input for lookup requires only K where as 
for comparison the required input is 2 pair objects. Putting this together:

typedef pair<string, int> Data;
class DataCompare {
public:
  bool operator() (const Data& lhs, const Data& rhs) const {
    return keyLess(lhs.first, rhs.first);
  }
  
  bool operator() (const Data& lhs, const Data::first_type& k) const {
    return keyLess(lhs.first, k);
  }
  
  bool operator() (const Data::first_type& k, const Data& rhs) const {
    return keyLess(k, rhs.first);
  }
  
private:
  bool keyLess(const Data::first_type& k1, const Data::first_type& k2) const {
    return k1 < k2;
  }
};
    
ITEM 24:
map::operator[] and map::insert() differ in performance
* Operator [] has add or update functionality. 

Add:
map<int, T> m;
m[1] = 1.50;
Operator [] returns a reference to the value.
If key is not present, it creates a new one by using the value type's default
constructor. Penalty comes from default constructing the object.
You may use m.insert(T::value_type(1, 1.50));

Update:
m[1] = 1.50
In this case operator[] is more efficient.

* Non standard associative containers: hash_set, hash_multiset, hash_map, 
hash_multimap


ITERATORS:
4 Types: iterator (T*), const_iterator(const T*), reverse_iterator(T*) and 
const reverse_iterator(const T*)

ITEM 26
* Implicit conversions available:
iterator         -> const_iterator
iterator         -> reverse_iterator
reverse_iterator -> iterator (using base() member function)
reverse_iterator -> const_reverse_iterator 
const_reverse_iterator -> reverse_iterator (using base() member function)

There is no way to convert from cons_iterator to iterator and 
const_reverse_iterator to reverse_iterator.

insert, erase and other container methods take iterators as input, so if you 
have const iterators you can't call these methods. Its better to use just  
iterators because you can always generate a const version from it if needed.

Item 27:
Use distance and advance to convert const_iterator to iterator
* Except for vector and strings, for all other container types iterators and 
const_iterators are different classes. So, a const_cast will not work.

iterator i(const_cast<iterator>(citer)) will not compile

ITEM 28:
Reverse iterators
* If you have access to the container the iterator came from, there is a safe
and portable way to convert.
iterator i(v.begin())
advance(i, distance(i, ci))  //move i up to ci
Actually, this call will not compile because advance() takes 2 InputIterator 
types. The class of i and ci are different and the iterator types deduced from
them are different.
advance(i, distance<ConstIter>(i,ci)); //Treat both as const iterator and get 
distance For random access iterator, this operation is very fast.

* Insertions when you have reverse iterator
You need to get regular iterator using ri.base() because the api takes only a
regular iterator.

 rend        rbegin
 x 1 2 3 4 5 x
   begin     end
   
when ri points to 3, ri.base() will point to 4
inserting X at ri means, move 1,2,3 left 1 cell and insert X -> 123X45
You would get the same behavior when you insert at ri.base() that is 4 -> 123X45
So, these iterators are equivalent for insertions.

* Deletions
Since i is to right of ri, you need to decrement it for deleting.
v.erase(--ri.base())
I.e. the iterators are not equivalent for deleting.

ITEM 29
Reading from a file into a string
* ifstream inputFile("foo.txt");
string data(istream_iterator<char>(inputFile), istream_iterator<char>());
  This fails to copy white space. Use
  inputFile.unsetf(ios::skipws);
  
istream_iterators use operator>> to do actual reading. Since, this is formatted
input it is very slow. Instead you can use
string data(istreambuf_iterator<char>(inputFile), istreambuf_iterator<char>());
This reads individual characters directly from the buffer. Every char is grabbed
including white space.

ALGORITHMS:
ITEM 30:
Make sure destination ranges are big enough. Most alrogithms write to
destination ranges by assignments.

	int foo(int x)
	vector<int> results;
	transform(v.begin(), v.end(), results.end(), foo);
Here, items are assigned in results and not inserted. If results doesn't have
have enough capacity, then it is a disaster.

We have to instead use 
	transform(v.begin(), v.end(), back_inserter(results), foo);
Here, the iterator returned by back_inserter calls a push_back() when
assignment operator is called. You can also use front_inserter().
You can use inserter() to insert at arbitrary locations.
inserter(results, results.begin() + results.size() / 2) -> insert in middle.

ITEM 31:
Sorting Options:
* If you are only looking for the top K items out of N items then you don't 
need to sort the complete container. Iters after K need not be sorted.
Use partial sort in this case.
	partial_sort(v.begin(), v.begin() + 20, v.end(), myCmp)
After this call the first 20 items are sorted in v.

* If you don't care about the order of first 20 elements, you use nth_element.
	nth_element(v.begin(), v.begin() + 20, v.end(), myCmp). Here the top 20 elems
are not sorted. It could be using partition and solve for 20th posisition.
Once the parition returns, all elements to the left of 20 are less than 20th
element.

* If there is tie between items, any item could be returned. We don't have
control. partial_sort and nth_element are not stable sorts. You have control
only for complete sorts. If you want stability you use stable_sort.

* nth_element() can be used to find the median value or find the value at a 
particular percentile. Replace the 2nd arg with the position you are looking
for. After the call, position points to the correct value.

* Suppose you want all the elements that meet a certain criteria to be at
the start of a container. We do not know how many. partial_sort and 
nth_element don't work.
	bool pred(const item&)
	vector<item>::iterator goodEnd = partition(v.begin(), v.end(), pred);
After this call, [v.begin(), goodEnd) has the list you are looking for.
If you want stability, you use stable_partition.

* sort, stable_sort, partial_sort, and nth_element need random access
iterators. So, they can only be applied to vectors, strings, deques and
arrays. Assoc container are already sorted and remain sorted at all times
using their comparison functions. Lists has its own sort() method. This
sort is stable.

* partition and stable_partition require only bidirectional iterators. So,
they can be used on any container.

* You can also use non-standard priority_queues for sorting. Non-standard
because it doesn't supporte iterators.

ITEM 32:
Remove
* ForwardIterator remove(ForwardIterator first, 
                       ForwardIterator last, 
                       const T& value)
remove doesn't receive the container, only iterators. And there is no way
go get container from iterator. Because there is no container, remove cannot
delete elements from it. We do not know which member function to invoke. If you
print the size after remove, the size doen't change. Removes basically moves all
unremoved elements to the top of the container. It returns an iterator that points
to one past the last unremoved element. We can't make any assumptions of the values
beyond new end(). They need not be removed elements. Remove operates by compacting.

* If you really want to remove elements and shrink number of items you should
also use erase.
	v.erase(remove(...), v.end())
list.remove() is a combination of erase and remove. For assoc container the method
is called erase(). 

* remove, remove_if and unique() have similar behaviour and correspond to similar
methods in list and assoc containers. unique() removes similar adjacent element.

* The remove-erase idiom doesnt work for pointers. It will lead to resource leaks
due to compaction.

ITEM 34:
Algorithms that work on sorted ranges
* binary_search, upper_bound, lower_bound, equal_range(), ...
set_union, set_intersection, set_symmetric_difference

ITEM 36
copy
* There are several versions of copy but no copy_if

ITEM 37:
Summarizing ranges  using accumulate or for_each
* count, count_if, min_element, max_element

* 	list<double>ld
	double sum = accumulate(ld.begin(), ld.end(), 0.0)
0.0 is the initial sum. Note, this has to be a double.
Then accumulate would use a double variable in its processing.
Accumulate only uses input iterators. So, it can be used for
istream_iterator and istreambuf iterators.


FUNCTORS:
* Neither C nor C++ allows you to truly pass functions as parameters to other
functions. Instead, you must pass poiters to functions. Function pointers 
are also passed by value. STL function objects are modelled after function
pointers, so they too are passed by value. The onus is on you to make sure
they behave well after copying. That means 1. They have to be small and
2. They must not be polymorphic - no virtual functions

* Function objects can have as much state as they want. Efficiency is 
important and we need to take care of slicing problem.

* There is a way to let function objects be hefty and polymorphic. Move the
data and polymorphism to a different class and have a member variable that
points to an object of this. You can use a shared pointer.

ITEM 39:
Make predicates pure functions
* Pure functions return value depends only on its input parameter. Kind of
stateless. A predicate is a function that returns bool or something that 
can be converted to a bool. They are used in assoc containers as comparison
functions, find_if, and various sorting algorithms.

* A predicate class is a functor class whose operator() function is a predicate.        
Function objects are always copied by value. So, if your function has nested calls,
remember each nested call will make a copy of the predicate and if predicate has 
state the change in state is lost after the call to nested function. You can't 
transfer the new state to next method.


ITEM 40:
Make functor classes adaptable
* Suppose you want to find out if a pointer points to an interesting widget this
  works:
	bool isInteresting(const Widget *pw)
	iterator i = find_if(v.begin(), v.end(), isInteresting)
	if (i != v.end())

* Suppose you want to find first pointer that is not interesting:
	find_if(v.begin(), v.end(), not1(isIntersting))
This will not compile. Each of the 4 standard function adapters: not1, not2,
bind1st and bind2nd require the existence of certain typedefs. Even if you are 
writing your own adapter, you have to provide these typedefs. Function objects
that provide these typedefs are said to be adaptable. 

* ptr_fun(isInteresting)
Takes a lowly pointer and returns an object that provides these typedefs.
The object probably overrides operator().

* The typedefs are argument_type, firsrt_argument_type, second_argument_type and 
result_type. The conventional way to provide them is to inherit them from a base 
class, or, more precisely , a base struct. For functor classes whose operator() 
takes one argument, the struct to inherit from is std::unary_function. For two 
arguments the struct to inherit from is std::binary_function. 

* unary and binary_functions are templates. You can't directly inherit from them.
You inherit from structs they generate and that requires you specify some type
arguments. For unary, you specify type parameter taken by your functor class's
operator() and return type. For binary you specify both the arguments for 
operator() and return type.

	template<typename T>
	class MeetsThreshold::public std::unary_function<Widget, bool> {
	private:
		const T threshold;
	public:
		bool operator()(const Widget&) const;
	};
	
	struct WidgetNameCompare: std::binary_function<Widget, Widget, bool> {
		bool operator(const Widget& lhs, const Widget& rhs) const;
	};

Note: Template param is Widget but operator() arg isn const Widget. In general,
non-pointer types passed to unary and binary_function have constants and
references stripped off. For pointer types, the args have to match exactly.

* By inheriting from unary and binary you get the typedef's automatically.

ITEM 41:
ptr_fun, mem_fun, mem_fun_ref
* Let f be a function and x be an object. 3 ways of calling f on x
	1. f(x)
	2. x.f()     // f is a member function and x is an obj or ref
	3. p->f()    // f is a member function and p is a pointer to x
Functions and function objects in STL are always invoked using syntax 1 i.e
non-member functions. Other kinds of call will not compile. Exmaple:
	for_each(v.begin(), v.end(), &Widget::test).

* mem_fun and mem_fun_ref arrange for member functions to be called using 
syntax 1. There are several declarations. One example is:
	template<typename R, typenameC> 
	mem_fun_t<R,C> mem_fun(R(C::*pmf)()) //fptr that takes nothin and returns R
	
mem_fun takes pointer to a member function, pmf, and returns an object
of type mem_fun_t. This declaration is for non-const member functions
taking no parameters. C is the class, R is the return type of the pointed
to member function. mem_fun_t is a function object that holds the member
function pointer and overrides operator() to invoke the encapsulated 
member function.
	for_each(v.begin(), v.end(), mem_fun(&Widget::test));
In each iteration of the for_each loop, syntax 1 is called on mem_fun_t 
which invokes operator(). Within operator(), syntax 3 is used to invoke the 
actual member function.

* mem_fun_t is called function object adapter. mem_fun_ref adapts syntax 
2 to syntax 1 while mem_fun_t adapted syntax 3 to syntax 1. Apart from adapting
these objects also provide important typedefs like original ptr_fun.

ITEM 42:
Make sure less<T> means operator <
Default comparison functions for assoc containers is less<T> and less<T> does
its work by calling operator <. Its bad to severe the ties between them. 
	template<> struct std::less<Widget>:
			public std::binary_function<Widget, Widget, bool> {
				bool operator() (const Widget& lhs, const Widget& rhs) const
				{
				 return lhs.maxSpeed() < rhs.maxSpeed();
				}
			};
			
Instead you could create a new compare class:
	public MaxSpeedCompare: public binary_function<..> {
		bool operator() (const Widget& lhs, const Widget& rhs) const
			{
			 return lhs.maxSpeed() < rhs.maxSpeed();
			}
	}




  

