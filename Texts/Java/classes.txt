* All java statments appear within a class, and all methods are implemented within it.

* From java 8, an interface can have a default implmentation for a method.

* Classes and interfaces are the most important of the five fundamental reference 
types defined by Java. Arrays, enums, and annotations are the other three.

* public class Integer extends Number implements Serializable, Comparable { 
// class members go here

Declarations may also include abstract and final. A class cannot be both abstract and final.

FIELDS/METHODS
Instance fields/methods
Class fields/methods

final -> variable cannot be changed after initialization
Fields can have initializers.
privateinta=17,b=37,c=53;

Fields that are both static and final are compile-time constants that javac may inline. 

Transient: 
This modifier specifies that a field is not part of the persistent state of an object 
and that it need not be serialized along with the rest of the object.
volatile:

This modifier indicates that the field has extra semantics for concurrent use by two or 
more threads. The volatile modifier says that the value of a field must always be read 
from and flushed to main memory, and that it may not be cached by a thread (in a register 
or CPU cache). 

CLASS FIELDS
There is only 1 copy of it.
public static final double PI = 3.14159; //Class constant
A public static field is essentially a global variable. Since we use fully qualified names
there will not be any name collissions.

CLASS METHODS
A class method cannot use any instance fields or instance methods because class methods are 
not associated with an instance of the class. 

public static double radiansToDegrees(double rads) { 
	return rads * 180 / PI;
}

double d = Circle.radiansToDegrees(2.0);

CONSTRUCTOR CHAINING
// This is the basic constructor: initialize the radius
public Circle(double r) { this.r = r; }
// This constructor uses this() to invoke the constructor above 
public Circle() { this(1.0); }

Refactor common initializing code and use chaining.
Important: this() has to be the first line in ctr.


FIELD DEFAULTS
Fields are automatically initialized. The default values are specified by java 
specification and apply to both instance and static fields.

You can also provide default values where they are declared.

Behind the scene, all the initializations are actually put in every
constructor and the fields appear in the order they are declared. A field
appearing later can use value from previous field.
public class SampleClass {
	public int len = 10;
	public int[] table = new int[len];
	public SampleClass() {
		for(int i = 0; i < len; i++) table[i] = i;
	}
}

Code generated by javac is equivalent to
public SampleClass() {
	len = 10;
	table = new int[len];
	for(int i = 0; i < len; i++) table[i] = i;
}

If a constructor begins with a this() call to another constructor, the field 
initialization code does not appear in the first constructor. Instead, the 
initialization is handled in the constructor invoked by the this() call.

Static fields have to be initialized even before a constructor is called.
javac generates a class initialization method automatically for every class. 
Class fields are initialized in the body of this method, which is invoked 
exactly once before the class is first used (often when the class is first 
loaded by the Java VM.)

The class initialization method is hidden. In the class file, it bears the name
<clinit>.

Java does allow us to write arbitrary code for the initialization of class fields, 
however, with a construct known as a static initializer. A static initializer is
simply the keyword static followed by a block of code in curly braces. A static 
initializer can appear in a class definition anywhere a field or method definition 
can appear. 

public class TrigCircle {
    // Here are our static lookup tables and their own initializers
	private static final int NUMPTS = 500;
	private static double sines[] = new double[NUMPTS]; 
	private static double cosines[] = new double[NUMPTS];
    
    // Here's a static initializer that fills in the arrays
	static {
		double x = 0.0;

		double delta_x = (Circle.PI/2)/(NUMPTS-1); 
		for(inti=0,x=0.0;i<NUMPTS;i++,x+=delta_x){
          sines[i] = Math.sin(x);
          cosines[i] = Math.cos(x);
    	}
	}
}

A class can have any number of static initializers. The body of each initializer block 
is incorporated into the class initialization method, along with any static field 
initialization expressions. 

Classes are also allowed to have instance initializers. An instance initializer is like 
a static initializer, except that it initializes an object, not a class. A class can have
any number of instance initializers, and they can appear anywhere a field or method 
definition can appear. The body of each instance initializer is inserted at the beginning 
of every constructor for the class, along with any field initialization expres‐ sions. 

 
EXTENDING A CLASS
public class PlaneCircle extends Circle {
 	public PlaneCircle(..) {
 		super(r);
 	}
}	
The call to the superclass constructor must appear as the first statement within
the constructor, even before local variable declarations. 	

If the superclass defines more than one constructor, super() can be used to invoke
any one of them, depending on the arguments passed.

An object can be assigned to a super class variable without a cast.
This is a widening conversion. We need a cast for the reverse.

Derived d = (Derived) b;

Final classes
When a class is declared with the final modifier, it means that it cannot be extended 
or subclassed. java.lang.String is an example of a final class. Declaring a class final 
prevents unwanted extensions to the class: if you invoke a method on a String object, 
you know that the method is the one defined by the String class itself, even if the 
String is passed to you from some unknown outside source.

The default superclass is Object. All java classes inherit the methods of Object.

Since a ctr has to be called every time an object is created, a super class ctr
must also be called when a subclass is created. If a subclass doesn't call super() then
, javac inserts one with no arguments by default. If super class doesn't have one then it
is a compilation error.

constructor calls are chained; any time an object is cre‐ ated, a sequence of constructors
is invoked, from subclass to superclass on up to Object at the root of the class hierarchy.
Because a superclass constructor is always invoked as the first statement of its subclass 
constructor, the body of the Object constructor always runs first, followed by the 
constructor of its subclass and on down the class hierarchy to the class that is being 
instantiated.

If a class has no constructor java inserts one with no arguments and calls super() in it. 
If you have at least one private constructor then the default ctr() is not inserted.

HIDING FIELDS
A field with the same name in child class hides the field in parent class.
To access the parent field we need to use super.x or cast 'this' to base class.
To access super parent field we need to cast 'this' to super parent.

Class fields can also be hidden. To refer to fields in parent you just need to
use the class name. No need to cast 'this'. Inherited methods still use base class
values. Looks like these are statically bound.

OVERRIDING SUPERCLASS METHODS
Unlike instance fields, methods with same signature override base class methods.
Methods use run time binding. Data uses compile time bindian.

Covariant Return: Return type of a method in child class may be a subclass of the return type
in the parent method.

CLass methods cannot be overridden. Just like fields, class methods can be hidden by a subclass 
but not overridden.

VIRTUAL POINTERS:
Virtual method lookup seems similar to C++. You can use the super keyword to invoke
base class method.

Casting a derived object to base object and calling the virtual method will still 
invoke the derived method due to virtual poiters. You have to use the super keyword.
With super, a modified form of virtual method lookup is performed. The first step, 
as in regular virtual method lookup, is to determine the actual class of the object
through which the method is invoked.When a method is invoked with the super syntax, 
however, the search begins at the superclass of the class. If the superclass implements 
the method directly, that version of the method is invoked. If the superclass inherits 
the method, the inherited version of the method is invoked. The most immediately
overridden version is called.

super.super.f() is illegal.

Clients using derived class can never invoke base classes version using super.
Super can be only used with in derived class code.


ACCESS CONTROL
Access control on a per-package basis is not directly part of the Java language.
When the class files that com‐ prise a package are stored in a directory, for 
A package that has been loaded is always accessible to code defined within the same package.
example, a user must have read access to the directory and the files within it 
in order to have access to the package.

Top level classes are accessible within the package in which they are defined.
If it is public, then it is accessible everywhere.

Default access level is package. Every member of every class is accessible to every
other member within the same package. You can restrict them using protected and private.

If a member of a class is declared protected, it is accessible to all classes within the 
package (the same as the default package accessibility) and also accessible within the 
body of any subclass of the class, regardless of the package in which that subclass is 
defined.

//package 1
class A {
	protected int i;
}

//package 2
class B extends A {
  void foo(A a) { a.i = 2; }  //Compiler error
  void foo2(B b); { b.i = 2; } //okay
} 

Within code, B can always access any member in other B.
Not the same with A here. If and A and B belonged to the same package then it is possible.

Every instance of a subclass does, in fact, include a complete instance of the superclass 
within it, including all inaccessible fields and methods.

* A class inherits all instance fields and instance methods (but not constructors) of its superclass.
* The body of a class can always access all the fields and methods it declares itself. 
It can also access the accessible fields and members it inherits from its superclass.

ABSTRACT CLASSES
Any class with an abstract method is automatically abstract itself and must be declared as such. 
To fail to do so is a compilation error.

static, private, and final methods cannot be abstract, because these types of methods cannot be 
overridden by a subclass. Similarly, a final class cannot contain any abstract methods.

public abstract class Shape {
	public abstract double area(); // Abstract methods: note 
	public abstract double circumference(); // semicolon instead of body.
}

* Converting a derived object to base class object is a widening conversion.
The other way is not and we need to cast.

* ClasCastException is thrown if converting an unrelated type.

CONVERTING ARRAYS
// Widening conversion from array to Object
Object o = new int[] {1,2,3}; // Later in the program...
int[] a = (int[]) o; // Narrowing conversion back to array type

In addition to converting an array to an object, an array can be converted to another type of array 
if the “base types” of the two arrays are reference types that can them‐ selves be converted. 
For example:
// Here is an array of strings.
String[] strings = new String[] { "hi", "there" };
// A widening conversion to CharSequence[] is allowed because String // can be widened to CharSequence
CharSequence[] sequences = strings;
// The narrowing conversion back to String[] requires a cast.
strings = (String[]) sequences;
// This is an array of arrays of strings
String[][] s = new String[][] { strings };
// It cannot be converted to CharSequence[] because String[] cannot be // converted to CharSequence: 
the number of dimensions don't match
sequences = s; // This line will not compile
// s can be converted to Object or Object[], because all array types // (including String[] and String[][]) 
can be converted to Object. Object[] objects = s;